## 실버1 1931 회의실 배정

- 문제 유형

   정렬, 그리디 알고리즘

- 공부한 점

  정렬방식의 문제 한가지 정렬 방식에 집중하지말고 다양한 정렬 방식을 생각해보고 적용한뒤 어떤 정렬 방식이 좋을지 선택해보자.

  - 2차원 배열의 정렬

    비교 기준이 없기때문에 Arrays.sort() 사용이 불가능하다.

    ```java
    int[][] arr = new int[][]{{5,40},{3,50},{1,30},{4,20},{2,10}};

    // 1. Comparator 익명 클래스 구현
    Arrays.sort(arr, new Comparator<int[]>() {
        @Override
        public int compare(int[] o1, int[] o2) {
            return o1[0]-o2[0]; // 첫번째 숫자 기준 오름차순 {1,30}{2,10}{3,50}{4,20}{5,40}
            //return o2[0]-o1[0]; // 첫번째 숫자 기준 내림차순 {5,40}{4,20}{3,50}{2,10}{1,30}
            //return o1[1]-o2[1]; // 두번째 숫자 기준 오름차순 {2,10}{4,20}{1,30}{5,40}{3,50}
            //return o2[1]-o1[1]; // 두번째 숫자 기준 내림차순 {3,50}{5,40}{1,30}{4,20}{2,10}
        }
    });
    
    // 다중 조건 
    int[][] arr2 = new int[][]{{5,40},{3,50},{1,30},{4,20},{2,10},{6,40},{6,50},{6,10},{6,20},{6,30}};
    
    Arrays.sort(arr2, new Comparator<int[]>() { 
        @Override
        public int compare(int[] o1, int[] o2) {
            return o1[0]!=o2[0] ? o1[0]-o2[0] : o1[1]-o2[1]; // 첫번째 기준 오름차순 > 두번째 기준 오름차순  : {1,30}{2,10}{3,50}{4,20}{5,40}{6,10}{6,20}{6,30}{6,40}{6,50}
            //return o1[0]!=o2[0] ? o1[0]-o2[0] : o2[1]-o1[1]; // 첫번째 기준 오름차순 > 두번째 기준 내림차순  : {1,30}{2,10}{3,50}{4,20}{5,40}{6,50}{6,40}{6,30}{6,20}{6,10}
        }
    });
    ```


    ```java
    Arrays.sort(arr, (o1, o2) -> {
    return o1[0]-o2[0]; // 첫번째 숫자 기준 오름차순 {1,30}{2,10}{3,50}{4,20}{5,40}
    });
    ```


    클래를 작성하는 방법과 람다식을 이용하는 방법이 존재하는데 람다식을 이용하는 방식이 더 쉬워보인다.
